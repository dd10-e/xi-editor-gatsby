{"data":{"markdownRemark":{"id":"e3b3971e-a314-5c04-adc0-30c2e2f21345","html":"<p><em>(originally written 22 Apr 2016)</em></p>\n<p>This post reflects actual working code, recently committed to the xi git repo. I’m proud of it. It draws on high-level mathematical concepts, but at the end of the day the design decisions are driven by hard-nosed engineering considerations.</p>\n<h2 id=\"word-wrapping\"><a href=\"#word-wrapping\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Word wrapping</h2>\n<p>I’ll focus on the fragment of the word wrapping problem most useful for code editing. In particular, I’ll assume for the sake of simplicity that it is trivial to compute the <em>width</em> of a given substring (in fact, code that relies on this assumption will stay, as I’ll rely on a “difficulty analysis” to detect whether it’s valid). Then, word wrapping can be defined as a scan through the document’s “candidate breaks,” and breaking either when the document has a hard break, or where there’s a soft break and adding the word (defined simply as the substring between two candidate breaks) when its width would cause the total line width to overflow.</p>\n<p>A simple way to get candidate breaks is just to consider the transition between space and non-space to be a soft break, but the Right Way is to use the Unicode <a href=\"http://unicode.org/reports/tr14/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">UAX #14</a> line breaking algorithm, so we do that. Either way, the interface is pretty simple, you basically call an iterator and on every call it gives you the next break.</p>\n<p>The basic idea can be expressed in a dozen lines or so lines of code, and indeed you’ll see that in, say, Python scripts that emit auto-generated code with not-terrible formatting.</p>\n<h2 id=\"functional-programming\"><a href=\"#functional-programming\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functional programming</h2>\n<p>The result of word wrapping an input string (given a target line length) is a pure function of its input. Further, there’s structure that can be exploited. At a minimum, every paragraph is independent. You can split on hard breaks (newlines, essentially), compute the word wrap of each paragraph, and stick them back together again, and get the same answer.</p>\n<p>Given that observation, there are many, many strategies for computing this function. You could compute it on the fly every time you needed it, you could store the computed result and invalidate it every time the input changed, etc. You can also try to break it into segments and use different strategies for each segment. I seriously considered monoid constructions that could be used to parallelize or incrementalize the problem, but ended up discarding them because they don’t have the best engineering characteristics. In xi, I choose to store the result of the word wrap calculation, so that the results are immediately (with O(log n) random access cost) available for scrolling. Deferring the calculation in any way increases the likelihood of jank, and indeed I see that in many editors on large files.</p>\n<p>Recomputing the whole thing on every edit would take too long to meet my performance targets (though it would probably still be faster than Atom). The only viable approach is some form of <em>incremental</em> computation.</p>\n<p>At a high level, incremental computation is using the explicit delta between the new value and the old value, plus the old value of the function, to compute the new one. If everything goes right, you get the same answer as if you had just computed the function from scratch over the new value (and, indeed, aggressively testing for this, especially in the face of random input, is a great thing to automate).</p>\n<p>Incremental computation is a universal pattern in GUI programming, because it’s almost always the case that rebuilding and redrawing the entire widget hierarchy from scratch every frame is too slow. Thus, the app pokes mutations at individual widgets, then those widgets propagate invalidations through the view hierarchy, and at the end of it the GUI framework redraws what it needs to. Still, making sure it’s a performance win requires care, because oftentimes the incremental computation is slower than a batch one would have been.</p>\n<p>A simple application of the incremental computation idea to line wrapping is to store the result of each paragraph separately, and for each paragraph not affected by the delta, just reuse that value. And indeed, that’s what DynamicLayout does in Android. There’s some bookkeeping involved to handle split and merged paragraphs, but overall it’s not too bad.</p>\n<p>However, it’s not really doing a minimal amount of work, especially if you have a very long paragraph. Worse, in the common case where only a line or two is affected, you’ve lost that information and have to redraw the entire paragraph.</p>\n<h2 id=\"an-editing-approach\"><a href=\"#an-editing-approach\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An editing approach</h2>\n<p>In xi, an edit on a rope is represented explicitly (there’s a data structure called Delta) as an interval in the original rope, and a new rope that replaces the interval. Delete and insert are special cases (the new rope and interval are empty, respectively). Then, the incremental line wrap problem is defined as a function that takes the underlying string, the delta, and the old breaks, and produces an edit on the breaks. The breaks themselves are stored and edited using the same b-tree rope infrastructure (conceptually it can be thought of as a string that is either “break” or “no break” at every code unit, but is of course encoded more efficiently than that).</p>\n<p>Seen this way, the problem turns out to be not particularly difficult. You start out two breaks back from the start of the edit, because an edit at the start of a line can cause a word to pop to the previous line (I could be smarter and only jump back one when it’s a hard break, but it wouldn’t make that much difference). Then, you run your word wrapper forward from that point. Once you hit a break which is both after the edit, and which agrees with an break in the previous wrap result (guaranteed to happen at the next hard break, if nothing else), you stop, and just edit what you’ve got in. All successive breaks will continue to occur at the same places as before, so you don’t have to touch them.</p>\n<p>Note that you don’t have to deal with “merging” or “splitting” of a line as special cases. If you want to know whether you need to scroll the part below the edit up or down, you can just count the number of breaks in the edited interval, before and after. Further, if the edit is small you can use that do do a minimal repaint (not yet implemented, just redrawing the screen is plenty fast enough on modern desktops, but I will do it as soon as the basics settle down).</p>\n<h2 id=\"results\"><a href=\"#results\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Results</h2>\n<p>My standard test file is a 300M chunk of ninja from the Android build process, with one line that’s 1.5M. It takes about 1s to load, and another 2s to word-wrap in bulk. This is pretty good, compared with about 30s to load and line-wrap in Sublime Text. Sublime also seems to be in the 100ms latency range when editing that long line. Atom fails to load the file entirely (and shows extremely noticeable jank in a file only 2M). Chrome also fails to scroll to the end of the 300M file (though it manages to display the first page of it pretty quick), and also janks on the 2M one.</p>\n<p>The speed of incremental word wrapping in xi is in the “almost too fast to measure” range. Instrumentation around the word wrap function clocks in at around 40µs, even on the long line, because nowhere is it touching the whole thing. It’s just looking at a small window around the edit, to produce a small edit to the line breaks structure.</p>\n<p>So without doing any more performance work at all, xi is quite competitive. But I have a few more tricks up my sleeve, and I’ll talk about those in an upcoming post.</p>\n<h3 id=\"in-comments\"><a href=\"#in-comments\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In comments</h3>\n<p>Nigel Tao asked about ligatures. I responded:</p>\n<p>Ok, the answer to your ligature question is complicated but hopefully interesting. This will be something of a mini-post.</p>\n<p>First, in the case of ASCII and a monospace font, ligatures and kerning aren't in effect and can't change the result of a word wrap operation. This is an important enough case that I will detect it and use extremely fast calculations for width.</p>\n<p>The other cases are also important, of course. Fundamentally, what you're trying to compute is the width of each \"word\". More precisely, you're trying to predict the total width of a line containing a sequence of words, so that it meets the necessary constraints (for editing, generally a greedy packing of the maximum allowable width into the line). And, to a first approximation, that line width is the sum of the individual words, minus the whitespace at the end.</p>\n<p>Now, <em>within</em> a word (in the non-ASCII or non-monospace cases), it's probably best not to make too many assumptions. In Latin script, editing a character will cause a small delta from the sum of the individual letter widths, but predicting that delta precisely is hard. Even with simplifying assumptions that kerning and ligature formation are pair-wise doesn't make the problem easy. The Knuth-Plass paper on line breaking (reprinted in \"Digital Typography\") considers the possibility that ligature formation will cascade, and basically recommend \"don't do that\" for the font creator. But once you get into complex script territory, all bets are off - a small edit can change whether a consonant cluster forms, whether an Arabic presentation form is initial or medial, etc., all of which can have huge impacts on width.</p>\n<p>So I don't recommend trying to do anything incremental within a word, just re-measure its width. This is of course potentially very expensive, and among other things, it's important to have a well-tuned cache.</p>\n<p>The other subtlety is, of course, those \"word\" boundaries. To do this in a principled way, you really want to know the boundaries that don't interact with width, ie if you segment the string at those boundaries, calculate the widths independently, and sum, you'll get the same answer. Most of the time, those boundaries line up pretty well with the line break boundaries, but not always. For one, the width boundaries are highly dependent on the font. At one extreme, in a monospace font, per-character is completely fine. On the other hand, if the font allows space to participate in kerning (or contextual substitutions) then your calculation will be off. This will happen in a high-quality Urdu (Nastaliq) font. Android hardcodes boundaries (the details are in getNextWordBreakForCache in Minikin's LayoutUtils.cpp) that work pretty well in practice, and xi will do something similar. HarfBuzz is also developing an API for querying a font do detect these boundaries, and in the future Android may well adopt it.</p>\n<p>Stuff like this is one of the reasons why I've started to see text as a sequence of codepoints in a loose hierarchy of boundaries, with no one particular assignment of boundaries being privileged.</p>","excerpt":"(originally written 22 Apr 2016) This post reflects actual working code, recently committed to the xi git repo. I’m proud of it. It draws on high-level mathematical concepts, but at the end of the day the design decisions are driven by hard-nosed engineering considerations. Word wrapping I’ll focus…","frontmatter":{"title":"Rope science, part 5 - incremental word wrapping"}},"allMarkdownRemark":{"edges":[{"node":{"id":"159ebaf9-aed2-5ad5-b403-f0a2c391cbef","fields":{"slug":"/frontend-notes/"},"frontmatter":{"title":"Notes on writing front-ends"}}},{"node":{"id":"db31e77f-3fda-57fc-9830-61c9f7c222dd","fields":{"slug":"/frontend-protocol/"},"frontmatter":{"title":"The Frontend Protocol"}}},{"node":{"id":"e81dd02d-d53d-5928-978d-37b7a16cdb61","fields":{"slug":"/plugin/"},"frontmatter":{"title":"Plugin architecture"}}},{"node":{"id":"056635a4-9cff-573b-9253-1c2afd68ff96","fields":{"slug":"/config/"},"frontmatter":{"title":"Working with the config system"}}},{"node":{"id":"ef83d327-af33-537c-b865-304c9cbd7567","fields":{"slug":"/crdt/"},"frontmatter":{"title":"CRDT - An approach to async plugins and undo"}}},{"node":{"id":"b075b8d5-5b27-557e-923b-cdd6d9a94273","fields":{"slug":"/config.1/"},"frontmatter":{"title":"Working with the config system"}}},{"node":{"id":"e7b10047-5613-53ea-bdeb-3989cfe8ac10","fields":{"slug":"/crdt-details/"},"frontmatter":{"title":"CRDT - The Xi Text Engine"}}},{"node":{"id":"8493f667-6117-50a0-bc92-21f304190a9f","fields":{"slug":"/fuchsia-ledger-crdts/"},"frontmatter":{"title":"CRDT - Using the Ledger for CRDTs"}}},{"node":{"id":"637adc80-f545-583f-b103-0e6256f0efe1","fields":{"slug":"/rope-science-00/"},"frontmatter":{"title":"Rope science - Introduction"}}},{"node":{"id":"d6abbbb0-ce0b-5810-8ab1-40db5f8fbb4d","fields":{"slug":"/rope-science-01/"},"frontmatter":{"title":"Rope science, part 1 - MapReduce for text"}}},{"node":{"id":"0b56a298-7fea-52be-b0c1-1924e8de94df","fields":{"slug":"/rope-science-02/"},"frontmatter":{"title":"Rope science, part 2 - metrics"}}},{"node":{"id":"f3d25a72-d849-52f7-8fb4-6d586db9b401","fields":{"slug":"/rope-science-03/"},"frontmatter":{"title":"Rope science, part 3 - Grapheme cluster boundaries"}}},{"node":{"id":"ed9dc1bf-9c35-58a0-b8ed-e702bdbc974f","fields":{"slug":"/rope-science-04/"},"frontmatter":{"title":"Rope science, part 4 - parenthesis matching"}}},{"node":{"id":"e3b3971e-a314-5c04-adc0-30c2e2f21345","fields":{"slug":"/rope-science-05/"},"frontmatter":{"title":"Rope science, part 5 - incremental word wrapping"}}},{"node":{"id":"271d1a9b-90e4-5315-b138-2a02a017e117","fields":{"slug":"/rope-science-06/"},"frontmatter":{"title":"Rope science, part 6 - parallel and asynchronous word wrapping"}}},{"node":{"id":"ef5e3b38-01da-5a9c-ad36-fce16dacff86","fields":{"slug":"/rope-science-08/"},"frontmatter":{"title":"Rope science, part 8 - CRDTs for concurrent editing"}}},{"node":{"id":"0c5f285f-2a9b-589f-8eff-a79435e54257","fields":{"slug":"/rope-science-09/"},"frontmatter":{"title":"Rope science, part 9 - CRDT Approach to Async Plugins and Undo"}}},{"node":{"id":"ef95af30-321f-5d87-a5e3-720e4eff00f9","fields":{"slug":"/rope-science-10/"},"frontmatter":{"title":"Rope science, part 10 - designing for a conflict-free world"}}},{"node":{"id":"4dd8698d-d45f-543c-9905-eba9659b68b0","fields":{"slug":"/rope-science-11/"},"frontmatter":{"title":"Rope science, part 11 - practical syntax highlighting"}}},{"node":{"id":"c8b885e6-57e4-5e66-9651-7b47f528793d","fields":{"slug":"/rope-science-12/"},"frontmatter":{"title":"Rope science, part 12 - minimal invalidation"}}}]}},"pageContext":{"id":"e3b3971e-a314-5c04-adc0-30c2e2f21345"}}