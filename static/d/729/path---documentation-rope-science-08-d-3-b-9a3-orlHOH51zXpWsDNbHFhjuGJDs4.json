{"data":{"markdownRemark":{"id":"ef5e3b38-01da-5a9c-ad36-fce16dacff86","html":"<p><em>(originally written 3 May 2016)</em></p>\n<p>To briefly recap: we want to run plugins asynchronously, so they have a little time to \"think\" (especially for things like deeper analysis of programs), but still not get in the way of typing responsiveness. Many problems of dealing with input methods are also fundamentally concurrent edits at heart. Asynchronous loading of a large file (appending chunks at the end) is also a form of concurrent edit, and it is essential not to get into inconsistent states.</p>\n<p>It would be a lot easier to just treat all editing operations as synchronous, but in xi we want to do better. For a while, operational transforms were considered the state of the art, but as Xoogler Joseph Gentle wrote, \"Unfortunately, implementing OT sucks. There's a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. ... Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.\"</p>\n<p>Conflict-free Replicated Data Types (CRDTs) are a solution. They are mostly discussed in a peer-to-peer context, with the usual assumptions of networks being partitioned, nodes failing, and mobile devices going offline for extended periods, because CRDTs actually work in that environment. A text editor is much easier. Is it possible to apply the ideas of CRDT, while exploiting the assumption that the editor core is fast and reliable, to create a simple implementation that nonetheless does the Right Thing? I believe the answer is yes.</p>\n<p>Let's start with highly simplified assumptions, to make life easier, and then back those off. First, let's assume we're only adding text, never deleting. Second, let's assume we have an oracle that knows the location where each character will land in the string at the end of the edit session. Obviously, such an oracle is unrealistic, but we'll figure out how to compute it on-the-fly after we've got the basic concurrent editing operations done.</p>\n<p>Given those assumptions, the basic editing operation is nearly trivial. You just represent your text as a sequence of cells, and the editing operation takes contents of the cell from empty to \"some character.\" For those familiar with CRDT theory, this operation is obviously a monotonic semi-lattice, and the update operation is equally obviously commutative - you can apply the updates in any order and get to the same result.</p>\n<p>Now, how would you go about computing the oracle? The key insight is that it's fairly easy to make any two snapshots align, given knowledge of the deltas. A snapshot is conceptually a view of the final string in which some of the cells are empty and some are not. So when you look at two snapshots, it's got some cells filled in common, some cells filled only in one, and some cells filled only in the other. The representation of a snapshot is simply the filled cells concatenated together. Then aligning two snapshots is basically figuring out a coordinate transform so that all of the filled cells in common line up.</p>\n<p>Take the simple case of inserting a sequence at some point. Then all coordinates less than that point are preserved, and for all coordinates greater, you add the length of the inserted sequence. This coordinate transform is, funny enough, pretty much the same as what you do for a gapped buffer. The coordinate exactly at that point is an interesting case, but I think the best way to approach it is tie-breaking based on the identity of who made the insert. For example, you'd want the spaces added by an autoindent plugin to come before keys typed by the user, because that more faithfully sustains the illusion that the autoindent plugin is infinitely fast.</p>\n<p>So, to make this a little more concrete: an actor (the user, a plugin) makes an editing request, which is an insertion of a sequence at a point relative to its snapshot of the buffer. The core then commits that request, which might require a coordinate transform based on other edits that have arrived in the meantime (ie between the current state and the snapshot referenced by the plugin). Actually very simple.</p>\n<p>But what about deletes? The straightforward way (deleting the sequence from the buffer, trying to do the same kind of coordinate transform, this time subtracting the length of the deleted subsequence) ruins commutativity. In fact, the whole model falls apart, making OT fiendishly complex and messy. The key insight of CRDT is that you can get back a monotonic update operation if you give each cell three states: empty, filled, and deleted, and each update progresses only forward through these states. In mathematical terms, this is a monotonic semi-lattice again. In a concrete implementation, you keep the spans around in your shared state, but mark them as deleted (these are known as \"tombstones\"), and of course do the deletion before actually rendering to the screen.</p>\n<p>Optionally, you can add some form of garbage collection to clean up the removed spans. In an editor, it's reasonable to assume that the amount of concurrency is very small. In fact, in most normal operation the buffer will often quiesce (no pending edits), at which point in the simplest case you can just delete out the spans. In practice, I suspect we'll need to keep some of the deleted spans around for undo (if you undo a delete, you really want the deleted text to appear in the same place relative to its context), but in even so I expect the number of edits in flight will be small enough you can use really simple algorithms. Let's say it's bounded by 20, then O(n^2) or even O(n^3) is fine.</p>\n<p>So I think it's possible to make the implementation very simple based on the fact that the core is fast and reliable, and that the scale of concurrency is limited. And if that does ever need to scale up (say, because this thing would get used to do actual collaborative editing), then the CRDT literature is rich in techniques for that.</p>\n<p>It feels like I can prototype this in a few days, as opposed to the long hard slog of trying to do OT from scratch. I'm looking forward to it, and looking forward to seeing what I learn, as these ideas still feel a little rough.</p>\n<h3 id=\"context\"><a href=\"#context\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context</h3>\n<p>I had written this post the day before:</p>\n<p>Homework for the next installment of the rope science series.</p>\n<p>I crammed some readings on CRDTs the past few days, and last night believe I came up with a clean, simple solution for dealing with concurrent editing by asynchronous plugins. I really recommend the CRDT concept, it hugely helped me focus my thinking. To make sense of my next post, it's kinda necessary to catch up on CRDTs.</p>\n<p>I recommend starting with <a href=\"https://www.microsoft.com/en-us/research/video/strong-eventual-consistency-and-conflict-free-replicated-data-types/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Marc Shapiro's 2011 talk</a> at Microsoft Research explaining the CRDT concept and the underlying mathematical concept of monotonic semi-lattice.</p>\n<p>The concept of CRDT actually started with the collaborative editing use case, before they generalized it to more general cloud-flavored problems (it now powers eventual consistency in Riak, among other things). The <a href=\"https://hal.inria.fr/inria-00071240/document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WOOT paper</a> (2006) is very good at comparing the new approach to operational transforms, but I'm definitely not going to adapt the details of that implementation.</p>\n<p>Lastly, I recommend reading <a href=\"http://hal.upmc.fr/inria-00555588/document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">A comprehensive study of Convergent and Commutative Replicated Data Types</a> (2011), which surveys many of the use cases and goes into more detail about the duality of the state-based and operation-based approaches to implementing CRDTs. It also provides a very useful retrospective on the application to collaborative text editing (WOOT and TreeDoc), placing the somewhat complex implementation details into a clean mathematical framework.</p>\n<p>Having read all this, at this point it's clear to me that CRDTs are the One True Way to do collaborative editing. The framework tells you clearly what you'd need to do to make operational transforms actually work (make the update operation commutative), why that's so difficult (delete operations lose state) and how to make your life much easier (retain delete state and do some form of GC after the fact). These talks and papers really helped me focus on what concurrency problem I'm trying to solve in xi and how to go about it.</p>\n<p>Similarly, differential synchronization is an interesting branch to explore (and a great demonstration that the full complexity of OT is not needed), but when the history of collaborative editing techniques is written, I believe it will have gotten lost in a merge conflict.</p>\n<p>If you've followed along with me so far, I believe the next post will be pretty exciting.</p>","excerpt":"(originally written 3 May 2016) To briefly recap: we want to run plugins asynchronously, so they have a little time to \"think\" (especially for things like deeper analysis of programs), but still not get in the way of typing responsiveness. Many problems of dealing with input methods are alsoâ€¦","frontmatter":{"title":"Rope science, part 8 - CRDTs for concurrent editing"}},"allMarkdownRemark":{"edges":[{"node":{"id":"159ebaf9-aed2-5ad5-b403-f0a2c391cbef","fields":{"slug":"/frontend-notes/"},"frontmatter":{"title":"Notes on writing front-ends"}}},{"node":{"id":"db31e77f-3fda-57fc-9830-61c9f7c222dd","fields":{"slug":"/frontend-protocol/"},"frontmatter":{"title":"The Frontend Protocol"}}},{"node":{"id":"e81dd02d-d53d-5928-978d-37b7a16cdb61","fields":{"slug":"/plugin/"},"frontmatter":{"title":"Plugin architecture"}}},{"node":{"id":"056635a4-9cff-573b-9253-1c2afd68ff96","fields":{"slug":"/config/"},"frontmatter":{"title":"Working with the config system"}}},{"node":{"id":"ef83d327-af33-537c-b865-304c9cbd7567","fields":{"slug":"/crdt/"},"frontmatter":{"title":"CRDT - An approach to async plugins and undo"}}},{"node":{"id":"e7b10047-5613-53ea-bdeb-3989cfe8ac10","fields":{"slug":"/crdt-details/"},"frontmatter":{"title":"CRDT - The Xi Text Engine"}}},{"node":{"id":"8493f667-6117-50a0-bc92-21f304190a9f","fields":{"slug":"/fuchsia-ledger-crdts/"},"frontmatter":{"title":"CRDT - Using the Ledger for CRDTs"}}},{"node":{"id":"637adc80-f545-583f-b103-0e6256f0efe1","fields":{"slug":"/rope-science-00/"},"frontmatter":{"title":"Rope science - Introduction"}}},{"node":{"id":"d6abbbb0-ce0b-5810-8ab1-40db5f8fbb4d","fields":{"slug":"/rope-science-01/"},"frontmatter":{"title":"Rope science, part 1 - MapReduce for text"}}},{"node":{"id":"0b56a298-7fea-52be-b0c1-1924e8de94df","fields":{"slug":"/rope-science-02/"},"frontmatter":{"title":"Rope science, part 2 - metrics"}}},{"node":{"id":"f3d25a72-d849-52f7-8fb4-6d586db9b401","fields":{"slug":"/rope-science-03/"},"frontmatter":{"title":"Rope science, part 3 - Grapheme cluster boundaries"}}},{"node":{"id":"ed9dc1bf-9c35-58a0-b8ed-e702bdbc974f","fields":{"slug":"/rope-science-04/"},"frontmatter":{"title":"Rope science, part 4 - parenthesis matching"}}},{"node":{"id":"e3b3971e-a314-5c04-adc0-30c2e2f21345","fields":{"slug":"/rope-science-05/"},"frontmatter":{"title":"Rope science, part 5 - incremental word wrapping"}}},{"node":{"id":"271d1a9b-90e4-5315-b138-2a02a017e117","fields":{"slug":"/rope-science-06/"},"frontmatter":{"title":"Rope science, part 6 - parallel and asynchronous word wrapping"}}},{"node":{"id":"ef5e3b38-01da-5a9c-ad36-fce16dacff86","fields":{"slug":"/rope-science-08/"},"frontmatter":{"title":"Rope science, part 8 - CRDTs for concurrent editing"}}},{"node":{"id":"0c5f285f-2a9b-589f-8eff-a79435e54257","fields":{"slug":"/rope-science-09/"},"frontmatter":{"title":"Rope science, part 9 - CRDT Approach to Async Plugins and Undo"}}},{"node":{"id":"ef95af30-321f-5d87-a5e3-720e4eff00f9","fields":{"slug":"/rope-science-10/"},"frontmatter":{"title":"Rope science, part 10 - designing for a conflict-free world"}}},{"node":{"id":"4dd8698d-d45f-543c-9905-eba9659b68b0","fields":{"slug":"/rope-science-11/"},"frontmatter":{"title":"Rope science, part 11 - practical syntax highlighting"}}}]}},"pageContext":{"id":"ef5e3b38-01da-5a9c-ad36-fce16dacff86"}}