{"data":{"markdownRemark":{"id":"e81dd02d-d53d-5928-978d-37b7a16cdb61","html":"<p><strong>Note:</strong> This document is mostly of historical interest. Although the\nhigh level details remain true, implementation details have changed,\nand remain in flux.</p>\n<h2>Philosophy</h2>\n<p>All serious programming editors have a mechanism for extensibility,\noften in the form of plugins, also often in terms of a scripting\nlanguage with bindings to editor objects.</p>\n<p>Xi follows the philosophy that plugins should be asynchronous, and it\nshould be possible to write them in any language. Thus, plugins are\ninvoked through RPC, and no language bindings are provided inside the\nfront-end or back-end process. A slow plugin should not interfere with\ntyping or other editing operations, and a crashing plugin should not\nlead to data loss.</p>\n<p>The idea of asynchrony is appealing, but actually implementing it is\nchallenging. The fundamental problem is that the plugin may provide\nedits (for example, inserting indentation in a language auto-indent\nmode) that happen at the same time as additional edits by the user.\nThese edits must be reconciled somehow. In some cases, specificially\nwhere the user edits are to the text and not the rich-text annotations,\nand the plugin edits are to the annotations but not the text (as will\noften be the case for syntax highlighting), there is no fundamental\nconflict and the overall system will eventually converge. (In this\ncase, it converges to the same state as running the plugin in batch\nmode over the text input, and this should be taken as a correctness\ncriterion for plugins that do incremental computation). In xi, I plan\nto address the challenge of parallel edits head-on, using some form\nof operational transforms or differential synchronization. One\npotential advantage of this approach is that it may make collaborative\nediting practical.</p>\n<p>In xi, not everything is a plugin. Even though the front-end to\nback-end communication is similarly mediated by RPC, the protocol is\nquite different.</p>\n<p>It is expected that most plugins will be written on top of a\nconvenience library. This library will provide caching for access to\nbuffer contents, and in general abstract away low-level details of the\nRPC protocol. Even so, it should stay small and simple, so it is\npractical to provide for a number of languages. Initially, I will\nprobably develop the plugin protocol and library using Python for\nrapid iteration, and then do Go and Rust, for higher performance.</p>\n<p>Xi will not provide a package manager, but rather will defer to\nexisting mechanisms. Using, for example, apt-get, brew, or chocolatey\nto install plugins should work well. Alternatively, others may choose\nto package a <em>distribution</em> containing the xi editor (front-end and\nback-end) along with a curated collection of plugins, as, for example,\n<a href=\"https://www.continuum.io/downloads\">Anaconda</a> does for IPython.</p>\n<h2>Basic architecture</h2>\n<h3>Invocation; config files</h3>\n<p>Deciding when to invoke a plugin, and how, is non-trivial. This starts\nwith a configuration file, which represents a <em>trigger</em> of when to\ninvoke the plugin, as well as a path to the plugin and some options. A\ntrigger can be a keyboard and/or menu command, a programming language\n(so basically a selector based on file extension), or hooks for other\nevents (an example would be running gofmt before every save).</p>\n<p>There are three levels of invocation: one-shot, per-buffer, and\neditor-global. In a one-shot invocation, the editor starts the child\nprocess, performs the RPC, and shuts down the process when the RPC\nis complete. In per-buffer invocation, the process stays open for the\nlife of the buffer. If more than one buffer requires the use of a\nplugin, xi will invoke multiple instances. In editor-global, a single\nprocess is expected to accept RPCs involving multiple buffers, and\nRPC requests are annotated with the buffer id.</p>\n<p>The config file also indicates the protocol version expected by the\nplugin, and xi will attempt to conform to a range of versions in\nactual use.</p>\n<p>Loading plugin info potentially has huge impact on startup time. Xi\nwill load all config files at startup, but will attempt to defer\nexecuting the plugin binaries. Thus, the format of the config files\nneeds to be quick to parse. I am leaning toward TOML as providing a\ngood balance. (YAML is an alternative, I'm considering it because it's\nrequired to process new-format\n<a href=\"https://www.sublimetext.com/docs/3/syntax.html\">Sublime Text syntax definitions</a>.)</p>\n<p>For developing plugins, the config file can direct the plugin to be\ncompiled at invocation time (\"go run\" or \"cargo run\", for example).\nThis mechanism should not be used for publishing plugins and\ndistributing them to users.</p>\n<p>I'm thinking that config files will be able to to \"include\" another\none. This would be the preferred way to handle optional plugins; they\nwould be stored in a directory that would not by default get processed\non editor startup, but a config file in a user-editable space can\npoint to another one.</p>\n<h3>Read access to the buffer</h3>\n<p>When attaching a buffer (ie, on startup of one-shot or per-buffer\nplugins), xi starts by sending a one-megabyte window of the buffer,\ncentered around the cursor. The plugin may request additional\nsubstrings of the buffer through RPC. Note that such requests access\na <em>snapshot</em> of the buffer, even if the user is concurrently editing.\nAs mentioned above, buffer access is one of the functions provided by\na convenience library - the actual plugin logic should be able to\nrequest an arbitrary substring, or iterate through all lines, and have\nthat served by cache and RPC on cache miss.</p>\n<p>When the RPC to the plugin completes, the snapshot is released. Any\nedits to the buffer are then sent as <em>deltas</em> to all plugins\nsubscribing to that buffer. Again, a major function of the convenience\nlibrary is to apply these deltas. The deltas may also, of course,\ntrigger computation, such as reapplying syntax coloring.</p>\n<h3>Write access to the buffer</h3>\n<p>The plugin can also send deltas back to the core, either in the course\nof RPC processing or spontaneously. These deltas can be to the text\nbuffer (for example, for indentation and electric brackets) and as\nrich text spans (for syntax highlighting).</p>\n<p>These deltas are suggestions; the core may need to reconcile them with\nother edits, and may possibly discard them. Xi will communicate back\nto the plugin to indicate whether the delta was accepted as-is or\nmodified. A sophisticated plugin may attempt to retry, based on more\nup-to-date information about edits to the buffer. This seems like a\nreasonable approach to implementing differential synchronization.</p>\n<p>Other responses from the plugin are expected to include:</p>\n<ul>\n<li>\n<p>Populating a completion menu.</p>\n</li>\n<li>\n<p>Displaying status messages.</p>\n</li>\n<li>\n<p>Popping up modal dialogs?</p>\n</li>\n<li>\n<p>What else?</p>\n</li>\n</ul>\n<h3>Asynchrony modes</h3>\n<p>Three asynchrony modes are anticipated. I might not implement all of\nthem.</p>\n<p>In synchronous mode, additional edits to the buffer are blocked until\nthe RPC to the plugin completes. Thus, the deltas produced by the\nplugin are applied as-is, with no possibility of conflicts from\nconcurrent edits. This is the simplest mode, but discouraged because\nit can cause typing lag.</p>\n<p>The normal mode is described above. During the life of an RPC, the\nplugin operates on a read-only snapshot of the buffer. No further\ndeltas are sent to the plugin until the RPC completes. At that point,\nthe xi core merges any resulting deltas with the other concurrent\nedits, and sends the plugin a notification of how the deltas were\nresolved. In this mode, much of the asychnronous nature is hidden from\nplugins; simple plugins can simply trust the core to reconcile the\ndeltas correctly, and take no further action</p>\n<p>In fully asynchronous mode, deltas are sent from the core to the\nplugin as soon as editing operations are made. My current thinking is\nthat each delta introduces a \"generation number,\" and that queries\nto retrieve buffer contents reference a specific generation number.</p>\n<p>The distinction between normal and fully asychronous modes may be\nimplemented simply as a choice of what the plugin chooses to do with\ndelta notifications - if it batches them up until the RPC completes,\nthen it is effectively normal mode. This also seems like a good\nfunction for the convenience library. Synchronous mode, however,\nrequires explicit cooperation from the editor, to prevent concurrent\nedits while an RPC is in flight.</p>\n<h2>Security</h2>\n<p>Plugins can potentially</p>\n<h2>Open questions</h2>\n<p>The state of the art technique for syntax highlighting is to store an\nexplicit highlighting state at the beginning of each line (in general,\nthis state consists of a stack of begin/end nested rules; it is in\ntheory unbounded but in practice will take on a small number\nof values). The fundamental syntax highlighting step, then, is a\nfunction that takes the line state and the text of a line, and\nproduces a set of rich text spans for the line, as well as the line\nstate for the beginning of the next line.</p>\n<p>A large part of the convenience library will be geared to efficient\nincremental computation based on these primitives. A key observation\nis that, when processing a delta, if you reach the same line (after\nthe parts changed by the delta) in the same state, you can stop\nprocessing; all subsequent highlighting will be untouched. Of course,\ntyping <code>/*</code> can cause a state change to cascade to the end of a\ndocument (this is one reason many \"electric\" modes auto-insert a\nclosing <code>*/</code> to try to keep such things balanced).</p>\n<p>The open question is: where should the state be stored? I'm leaning\nto do it in the plugin, but a case can be made for letting the core\nfunction as a \"database\" that can store this information efficiently\neven for huge files. Note though, the state info can be considered a\ncache, because it is always possible to reconstruct it by scanning\nfrom the beginning of the buffer.</p>\n<h3>Additional use cases</h3>\n<p>Many of these use cases are ambitious, requiring sophisticated UI\nwiring; they are unlikely to be implemented soon but might be worth\nthinking about.</p>\n<ul>\n<li>\n<p>Access to version control (maybe including display of diffs, or,\nmore ambitiously, providing UI to do interactive merging).</p>\n</li>\n<li>\n<p>Embedding in a debugger (just annotating breakpoints and the like\nshould be fairly straightforward).</p>\n</li>\n<li>\n<p>Source code navigation, including reference hierarchies.</p>\n</li>\n</ul>\n<h2>References</h2>\n<h3>Other editors</h3>\n<ul>\n<li>\n<p><a href=\"https://github.com/neovim/neovim/wiki/Plugin-UI-architecture\">Neovim</a>.\nAsynchronous RPC-based. GUI front-ends are another form of plugin.</p>\n</li>\n<li>\n<p><a href=\"http://www.sublimetext.com/docs/api-reference\">Sublime Text</a>.\nBasically exposes editor objects (views, windows, regions, etc)\nthrough Python bindings.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/martanne/vis#lua-api-for-in-process-extension\">Vis</a>.\nLua bindings for in-process extension, used for syntax highlighting\n(which is also PEG-based).</p>\n</li>\n</ul>\n<h3>Editor prototypes</h3>\n<ul>\n<li>\n<p><a href=\"https://github.com/swiboe/swiboe#swiboe---\">Swiboe</a>\n(\"<strong>Swi</strong>tch<strong>bo</strong>ard <strong>e</strong>ditor\"). Everything is a plugin.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/wi-ed/wi\">Wi</a>. Fully asychronous, written in Go.</p>\n</li>\n</ul>\n<h3>Fundamental technology</h3>\n<ul>\n<li>\n<p><a href=\"https://neil.fraser.name/writing/sync/\">Differential Synchronization</a>.</p>\n</li>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Operational_transformation\">Operational transformation</a>.</p>\n</li>\n<li>\n<p><a href=\"http://www.jsonrpc.org/specification\">JSON-RPC 2.0 Specification</a>.</p>\n</li>\n</ul>","frontmatter":{"title":"Plugin architecture"}},"site":{"siteMetadata":{"title":"Gatsby Blog Tailwindcss","titleSeparator":"|"}}},"pageContext":{"id":"e81dd02d-d53d-5928-978d-37b7a16cdb61"}}